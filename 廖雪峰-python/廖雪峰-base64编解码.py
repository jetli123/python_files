# -*- coding: utf-8 -*-
"""
    Base64 是一种用 64 个字符来表示任意二进制数据转换到字符串的方法。
"""
"""64位编码表"""
# ['A', 'B', 'C', 'D', 'E', 'F', 'G', ... , 'X', 'Y', 'Z', 'a', 'b', 'c', ... ,
# 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', ... , '9', '+', '/']
# """
# 原理：
#     Base64 的原理很简单，首先，准备一个包含 64 个字符的数组：
# 然后，对二进制数据进行处理，每 3 个字节一组，一共是 3x8=24bit，划
# 为 4 组，每组正好 6 个 bit：
#     这样我们得到 4 个数字作为索引，然后查表，获得相应的 4 个字符，就
# 是编码后的字符串。
#     所以，Base64 编码会把 3 字节的二进制数据编码为 4 字节的文本数据，
# 长度增加 33%，好处是编码后的文本数据可以在邮件正文、网页等直接
# 显示。
#     如果要编码的二进制数据不是 3 的倍数，最后会剩下 1 个或 2 个字节怎
# 么办？Base64 用\x00 字节在末尾补足后，再在编码的末尾加上 1 个或 2
# 个=号，表示补了多少字节，解码的时候，会自动去掉。
# """
import base64

print(base64.b64encode(b'binary string abc'))
# YmluYXJ5AHN0cmluZwBhYmM=
print(base64.b64decode(b'YmluYXJ5AHN0cmluZwBhYmM='))
# binary string abc

# 由于标准的 Base64 编码后可能出现字符+和/，在 URL 中就不能直接作
# 为参数，所以又有一种"url safe"的 base64 编码，其实就是把字符+和/分
# 别变成-和_：
print(base64.b64encode(b'i\xb7\x1d\xfb\xef\xff'))
# abcd++//
print(base64.urlsafe_b64encode(b'i\xb7\x1d\xfb\xef\xff'))
# abcd--__   将 ++// 转换为 --__
print(base64.urlsafe_b64decode(b'abcd--__'))

# 例子：推算 b 的 base64 编码
# bin(ord('b'))  # 0b1100010
# 011000 10 的base64编码，以6位分割, 所以 分割成 011000 10
"""base64编码的一个字节6位，传统的一个字节8位，最小公倍数为24。那么base64编码最小单位即为24/6=4个字符"""
# 所以：
# 第一位011000 以最小4个字符表示为：0001 1000， 10进制为 24，对应base64字符编码对照表为：Y
# 第二位10 表示为 0010 0000 ， 10进制为 32, 对应base64字符编码对照表为：g
# 由于‘b’后面bit位都是0，base64约定以‘=’代替
# 所以 第一第二位 可以表示为 ： 0001 1000(Y) 0010 0000(g) 0000 0000(=) 0000 0000(=)
# 所以 base64 编码为 b <==> Yg==


"""练习：i"""
print(bin(ord('i')))  # 0b1101001
# 01101001 00000000 00000000  以24位，8位分割表示：
# 011010 010000 000000 000000  以24位，6位分割表示:
# 6位如何以8位形式表示，在前面补0，即
# 011010 加两个0 ：00011010 对应10进制= 26  对应base64编码表为 a
# 010000 加两个0 ：00010000 对应10进制= 16   对应base64编码表为 Q
# 000000 加两个0 ：00000000 0，             base64约定以‘=’代替
# 000000 加两个0 ：00000000 0,              base64约定以‘=’代替
"""结论：i 的 base64位编码为：aQ=="""
